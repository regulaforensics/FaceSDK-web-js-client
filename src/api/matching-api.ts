/* tslint:disable */
/* eslint-disable */
/**
 * Regula Face SDK Web API
 * <a href=\"https://regulaforensics.com/products/face-recognition-sdk/  \" target=\"_blank\">Regula Face SDK</a> is a cross-platform biometric verification solution for a digital identity verification process and image quality assurance. The SDK enables convenient and reliable face capture on the client side (mobile, web, and desktop) and further processing on the client or server side.   The Face SDK includes the following features:  * <a href=\"https://docs.regulaforensics.com/develop/face-sdk/overview/introduction/#face-detection\" target=\"_blank\">Face detection and image quality assessment</a> * <a href=\"https://docs.regulaforensics.com/develop/face-sdk/overview/introduction/#face-comparison-11\" target=\"_blank\">Face match (1:1)</a> * <a href=\"https://docs.regulaforensics.com/develop/face-sdk/overview/introduction/#face-identification-1n\" target=\"_blank\">Face search (1:N)</a> * <a href=\"https://docs.regulaforensics.com/develop/face-sdk/overview/introduction/#liveness-assessment\" target=\"_blank\">Liveness detection</a>  Here is the <a href=\"https://github.com/regulaforensics/FaceSDK-web-openapi  \" target=\"_blank\">OpenAPI specification on GitHub</a>.   ### Clients * [JavaScript](https://github.com/regulaforensics/FaceSDK-web-js-client) client for the browser and node.js based on axios * [Java](https://github.com/regulaforensics/FaceSDK-web-java-client) client compatible with jvm and android * [Python](https://github.com/regulaforensics/FaceSDK-web-python-client) 3.5+ client * [C#](https://github.com/regulaforensics/FaceSDK-web-csharp-client) client for .NET & .NET Core 
 *
 * The version of the OpenAPI document: 6.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { DetectRequest } from '../models';
// @ts-ignore
import { DetectResponse } from '../models';
// @ts-ignore
import { MatchAndSearchRequest } from '../models';
// @ts-ignore
import { MatchAndSearchResponse } from '../models';
// @ts-ignore
import { MatchRequest } from '../models';
// @ts-ignore
import { MatchResponse } from '../models';
/**
 * MatchingApi - axios parameter creator
 * @export
 */
export const MatchingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Detect face, evaluate attributes, assess the portrait quality
         * @param {DetectRequest} detectRequest 
         * @param {string} [xRequestID] Request header label.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detect: async (detectRequest: DetectRequest, xRequestID?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detectRequest' is not null or undefined
            assertParamExists('detect', 'detectRequest', detectRequest)
            const localVarPath = `/api/detect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRequestID !== undefined && xRequestID !== null) {
                localVarHeaderParameter['X-RequestID'] = String(xRequestID);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(detectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To perform a comparison of faces in the same image or in two different images, use POST `/api/match`. It\'s possible to compare faces in the same image or in two different images, this is defined by the `images.type` parameter. <br><br> The face detection result is displayed in the `detections` field. Each face is identified by two parameters: `faceIndex` (the index number of the face) and `imageIndex` (the index number of the image on which the face is detected). So, if there are two images each of which has two faces in them, the parameters will be the following: - First face in the first image: `faceIndex: 0`, `imageIndex: 0` - Second face in the first image: `faceIndex: 1`, `imageIndex: 0` - First face of the second image: `faceIndex: 0`, `imageIndex: 1` - Second face in the second image: `faceIndex: 1`, `imageIndex: 1`
         * @summary compare faces (1:1)
         * @param {MatchRequest} matchRequest 
         * @param {string} [xRequestID] Request header label.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        match: async (matchRequest: MatchRequest, xRequestID?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'matchRequest' is not null or undefined
            assertParamExists('match', 'matchRequest', matchRequest)
            const localVarPath = `/api/match`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRequestID !== undefined && xRequestID !== null) {
                localVarHeaderParameter['X-RequestID'] = String(xRequestID);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(matchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To compare several images from a document and look up a person in the database in one request, use POST `/api/match_and_search`. In this case, the calculation of the descriptor will be performed only once, as opposed to using two requests for the same operation. If only one person is identified, matching is not performed and only search is carried out.
         * @summary match and search (1:1 + 1:N)
         * @param {MatchAndSearchRequest} matchAndSearchRequest 
         * @param {string} [xRequestID] Request header label.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchAndSearch: async (matchAndSearchRequest: MatchAndSearchRequest, xRequestID?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'matchAndSearchRequest' is not null or undefined
            assertParamExists('matchAndSearch', 'matchAndSearchRequest', matchAndSearchRequest)
            const localVarPath = `/api/match_and_search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRequestID !== undefined && xRequestID !== null) {
                localVarHeaderParameter['X-RequestID'] = String(xRequestID);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(matchAndSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MatchingApi - functional programming interface
 * @export
 */
export const MatchingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MatchingApiAxiosParamCreator(configuration)
    return {
        /**
         * Detect face, evaluate attributes, assess the portrait quality
         * @param {DetectRequest} detectRequest 
         * @param {string} [xRequestID] Request header label.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detect(detectRequest: DetectRequest, xRequestID?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detect(detectRequest, xRequestID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To perform a comparison of faces in the same image or in two different images, use POST `/api/match`. It\'s possible to compare faces in the same image or in two different images, this is defined by the `images.type` parameter. <br><br> The face detection result is displayed in the `detections` field. Each face is identified by two parameters: `faceIndex` (the index number of the face) and `imageIndex` (the index number of the image on which the face is detected). So, if there are two images each of which has two faces in them, the parameters will be the following: - First face in the first image: `faceIndex: 0`, `imageIndex: 0` - Second face in the first image: `faceIndex: 1`, `imageIndex: 0` - First face of the second image: `faceIndex: 0`, `imageIndex: 1` - Second face in the second image: `faceIndex: 1`, `imageIndex: 1`
         * @summary compare faces (1:1)
         * @param {MatchRequest} matchRequest 
         * @param {string} [xRequestID] Request header label.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async match(matchRequest: MatchRequest, xRequestID?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.match(matchRequest, xRequestID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To compare several images from a document and look up a person in the database in one request, use POST `/api/match_and_search`. In this case, the calculation of the descriptor will be performed only once, as opposed to using two requests for the same operation. If only one person is identified, matching is not performed and only search is carried out.
         * @summary match and search (1:1 + 1:N)
         * @param {MatchAndSearchRequest} matchAndSearchRequest 
         * @param {string} [xRequestID] Request header label.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async matchAndSearch(matchAndSearchRequest: MatchAndSearchRequest, xRequestID?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchAndSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.matchAndSearch(matchAndSearchRequest, xRequestID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MatchingApi - factory interface
 * @export
 */
export const MatchingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MatchingApiFp(configuration)
    return {
        /**
         * Detect face, evaluate attributes, assess the portrait quality
         * @param {DetectRequest} detectRequest 
         * @param {string} [xRequestID] Request header label.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detect(detectRequest: DetectRequest, xRequestID?: string, options?: any): AxiosPromise<DetectResponse> {
            return localVarFp.detect(detectRequest, xRequestID, options).then((request) => request(axios, basePath));
        },
        /**
         * To perform a comparison of faces in the same image or in two different images, use POST `/api/match`. It\'s possible to compare faces in the same image or in two different images, this is defined by the `images.type` parameter. <br><br> The face detection result is displayed in the `detections` field. Each face is identified by two parameters: `faceIndex` (the index number of the face) and `imageIndex` (the index number of the image on which the face is detected). So, if there are two images each of which has two faces in them, the parameters will be the following: - First face in the first image: `faceIndex: 0`, `imageIndex: 0` - Second face in the first image: `faceIndex: 1`, `imageIndex: 0` - First face of the second image: `faceIndex: 0`, `imageIndex: 1` - Second face in the second image: `faceIndex: 1`, `imageIndex: 1`
         * @summary compare faces (1:1)
         * @param {MatchRequest} matchRequest 
         * @param {string} [xRequestID] Request header label.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        match(matchRequest: MatchRequest, xRequestID?: string, options?: any): AxiosPromise<MatchResponse> {
            return localVarFp.match(matchRequest, xRequestID, options).then((request) => request(axios, basePath));
        },
        /**
         * To compare several images from a document and look up a person in the database in one request, use POST `/api/match_and_search`. In this case, the calculation of the descriptor will be performed only once, as opposed to using two requests for the same operation. If only one person is identified, matching is not performed and only search is carried out.
         * @summary match and search (1:1 + 1:N)
         * @param {MatchAndSearchRequest} matchAndSearchRequest 
         * @param {string} [xRequestID] Request header label.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchAndSearch(matchAndSearchRequest: MatchAndSearchRequest, xRequestID?: string, options?: any): AxiosPromise<MatchAndSearchResponse> {
            return localVarFp.matchAndSearch(matchAndSearchRequest, xRequestID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MatchingApi - object-oriented interface
 * @export
 * @class MatchingApi
 * @extends {BaseAPI}
 */
export class MatchingApi extends BaseAPI {
    /**
     * Detect face, evaluate attributes, assess the portrait quality
     * @param {DetectRequest} detectRequest 
     * @param {string} [xRequestID] Request header label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchingApi
     */
    public detect(detectRequest: DetectRequest, xRequestID?: string, options?: AxiosRequestConfig) {
        return MatchingApiFp(this.configuration).detect(detectRequest, xRequestID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To perform a comparison of faces in the same image or in two different images, use POST `/api/match`. It\'s possible to compare faces in the same image or in two different images, this is defined by the `images.type` parameter. <br><br> The face detection result is displayed in the `detections` field. Each face is identified by two parameters: `faceIndex` (the index number of the face) and `imageIndex` (the index number of the image on which the face is detected). So, if there are two images each of which has two faces in them, the parameters will be the following: - First face in the first image: `faceIndex: 0`, `imageIndex: 0` - Second face in the first image: `faceIndex: 1`, `imageIndex: 0` - First face of the second image: `faceIndex: 0`, `imageIndex: 1` - Second face in the second image: `faceIndex: 1`, `imageIndex: 1`
     * @summary compare faces (1:1)
     * @param {MatchRequest} matchRequest 
     * @param {string} [xRequestID] Request header label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchingApi
     */
    public match(matchRequest: MatchRequest, xRequestID?: string, options?: AxiosRequestConfig) {
        return MatchingApiFp(this.configuration).match(matchRequest, xRequestID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To compare several images from a document and look up a person in the database in one request, use POST `/api/match_and_search`. In this case, the calculation of the descriptor will be performed only once, as opposed to using two requests for the same operation. If only one person is identified, matching is not performed and only search is carried out.
     * @summary match and search (1:1 + 1:N)
     * @param {MatchAndSearchRequest} matchAndSearchRequest 
     * @param {string} [xRequestID] Request header label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchingApi
     */
    public matchAndSearch(matchAndSearchRequest: MatchAndSearchRequest, xRequestID?: string, options?: AxiosRequestConfig) {
        return MatchingApiFp(this.configuration).matchAndSearch(matchAndSearchRequest, xRequestID, options).then((request) => request(this.axios, this.basePath));
    }
}
